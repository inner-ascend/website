var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf,
  __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: !0
    });
  },
  __copyProps = (to, from, except, desc) => {
    if (from && typeof from == "object" || typeof from == "function") for (let key of __getOwnPropNames(from)) !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    });
    return to;
  };
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: !0
  }) : target, mod)),
  __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
    value: !0
  }), mod);
var devServerClient_exports = {};
__export(devServerClient_exports, {
  client: () => client,
  disable: () => disable,
  enable: () => enable,
  log: () => log,
  registerBundle: () => registerBundle,
  setup: () => setup
});
module.exports = __toCommonJS(devServerClient_exports);
var import_pretty_format = __toESM(require("pretty-format")),
  import_getDevServerLocation = require("./getDevServerLocation.cjs"),
  import_hmr_client = require("./hmr-client.cjs");
(0, import_hmr_client.loadHMRClient)();
class DevServerClient {
  socket;
  buffer = [];
  constructor() {
    const initSocket = () => {
      const address = `ws://${(0, import_getDevServerLocation.getDevServerLocation)().host}/__client`;
      this.socket = new WebSocket(address);
      const onClose = event => {
        console.warn("Disconnected from the Dev Server:", event.message), this.socket = void 0;
      };
      this.socket.onclose = onClose, this.socket.onerror = onClose, this.socket.onopen = () => {
        this.flushBuffer();
      };
    };
    process.env.NODE_ENV === "development" && initSocket();
  }
  send(level, data) {
    try {
      this.socket?.send(JSON.stringify({
        type: "client-log",
        level,
        data: data.map(item => typeof item == "string" ? item : (0, import_pretty_format.default)(item, {
          escapeString: !0,
          highlight: !0,
          maxDepth: 3,
          min: !0,
          plugins: [
          // @ts-expect-error
          import_pretty_format.default.plugins.ReactElement]
        }))
      }));
    } catch {
      try {
        this.socket?.send(JSON.stringify({
          type: "client-log",
          level,
          data: data.map((item, index) => {
            try {
              return typeof item == "string" ? item : JSON.stringify(item);
            } catch (err) {
              return `Error stringifying item at index ${index} - ${item} - ${err}`;
            }
          })
        }));
      } catch (err) {
        try {
          this.socket?.send(JSON.stringify({
            type: "client-log",
            level: "error",
            data: ["error sending client log: " + err]
          }));
        } catch {}
      }
    }
  }
  flushBuffer() {
    globalThis.__vxrnTmpLogs && (globalThis.__vxrnTmpLogs.forEach(({
      level,
      data
    }) => {
      this.buffer.push({
        level,
        data
      });
    }), delete globalThis.__vxrnTmpLogs);
    for (const {
      level,
      data
    } of this.buffer) this.send(level, data);
    this.buffer = [];
  }
  log(level, data) {
    if (level !== "groupEnd") if (this.socket && this.socket.readyState === WebSocket.OPEN) this.flushBuffer(), this.send(level, data);else {
      if (globalThis.__vxrnTmpLogs) return;
      this.buffer.push({
        level,
        data
      });
    }
  }
}
const client = new DevServerClient(),
  setup = () => {},
  enable = () => {},
  disable = () => {},
  registerBundle = () => {},
  log = (level, data) => {
    client.log(level, data);
  };