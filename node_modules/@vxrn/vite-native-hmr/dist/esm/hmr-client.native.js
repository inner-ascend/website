import { getDevServerLocation } from "./getDevServerLocation";
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
var HMRClient = /* @__PURE__ */ function() {
  "use strict";
  function HMRClient2(app) {
    var _this = this;
    _class_call_check(this, HMRClient2), _define_property(this, "app", void 0), _define_property(this, "url", void 0), _define_property(this, "socket", void 0), _define_property(this, "lastHash", void 0), this.app = app, this.lastHash = "";
    var port = process.env.REACT_NATIVE_SERVER_PUBLIC_PORT || 8081;
    this.url = `ws://${getDevServerLocation().hostname}:${port}/__hmr?platform=${process.env.REACT_NATIVE_PLATFORM || "ios"}`, this.socket = new WebSocket(this.url), console.info(" \u24F5 [hmr] connecting..."), this.socket.onopen = function() {
      console.info(" \u24F5 [hmr] connected");
    }, this.socket.onclose = function() {
      console.info(` \u24F5 [hmr] disconnected ${_this.url}`);
    }, this.socket.onerror = function(event) {
      console.error(" \u24F5 [hmr] error", event);
    }, this.socket.onmessage = function(event) {
      try {
        var data = JSON.parse(event.data.toString());
        _this.processMessage(data);
      } catch (error) {
        console.warn(" \u24F5 [hmr] invalid message", error);
      }
    };
  }
  return _create_class(HMRClient2, [
    {
      key: "upToDate",
      value: function(hash) {
        return hash && (this.lastHash = hash), this.lastHash === __webpack_hash__;
      }
    },
    {
      key: "processMessage",
      value: function(message) {
        switch (message.action) {
          case "building":
            var _message_body;
            this.app.LoadingView.showMessage("Rebuilding...", "refresh"), console.info(" \u24F5 [hmr] bundle rebuilding", {
              name: (_message_body = message.body) === null || _message_body === void 0 ? void 0 : _message_body.name
            });
            break;
          // biome-ignore lint/suspicious/noFallthroughSwitchClause: <explanation>
          case "built":
            var _message_body1, _message_body2;
            console.info(" \u24F5 [hmr] bundle rebuilt", {
              name: (_message_body1 = message.body) === null || _message_body1 === void 0 ? void 0 : _message_body1.name,
              time: (_message_body2 = message.body) === null || _message_body2 === void 0 ? void 0 : _message_body2.time
            });
          // Fall through
          case "sync":
            var _message_body_errors, _message_body_warnings;
            if (!message.body) {
              console.warn(" \u24F5 [hmr] message body is empty");
              return;
            }
            if (!((_message_body_errors = message.body.errors) === null || _message_body_errors === void 0) && _message_body_errors.length) {
              message.body.errors.forEach(function(error) {
                console.error("Cannot apply update due to error:", error);
              }), this.app.LoadingView.hide();
              return;
            }
            !((_message_body_warnings = message.body.warnings) === null || _message_body_warnings === void 0) && _message_body_warnings.length && message.body.warnings.forEach(function(warning) {
              console.warn(" \u24F5 [hmr] bundle contains warnings:", warning);
            }), this.applyUpdate(message.body);
        }
      }
    },
    {
      key: "applyUpdate",
      value: function(update) {
        if (!module.hot)
          throw new Error(" \u24F5 [hmr] hot Module Replacement is disabled.");
        !this.upToDate(update.hash) && module.hot.status() === "idle" && (console.info(" \u24F5 [hmr] checking for updates on the server..."), this.checkUpdates(update));
      }
    },
    {
      key: "checkUpdates",
      value: function(update) {
        var _this = this;
        try {
          var _module_hot;
          this.app.LoadingView.showMessage("Refreshing...", "refresh"), (_module_hot = module.hot) === null || _module_hot === void 0 || _module_hot.check(!1).then(function(updatedModules) {
            var _module_hot3;
            if (!updatedModules) {
              console.warn(" \u24F5 [hmr] cannot find update - full reload needed"), _this.app.reload();
              return;
            }
            (_module_hot3 = module.hot) === null || _module_hot3 === void 0 || _module_hot3.apply({
              ignoreDeclined: !0,
              ignoreUnaccepted: !1,
              ignoreErrored: !1,
              onDeclined: function(data) {
                console.warn(" \u24F5 [hmr] ignored an update due to declined module", {
                  chain: data.chain
                });
              }
            }).then(function(renewedModules) {
              _this.upToDate() || _this.checkUpdates(update);
              var unacceptedModules = updatedModules.filter(function(moduleId) {
                return renewedModules && renewedModules.indexOf(moduleId) < 0;
              });
              unacceptedModules.length ? (console.warn(" \u24F5 [hmr] not every module was accepted - full reload needed", {
                unacceptedModules
              }), _this.app.reload()) : (console.info(" \u24F5 [hmr] renewed modules - app is up to date", {
                renewedModules
              }), _this.app.dismissErrors());
            });
          });
        } catch (error) {
          var _module_hot1, _module_hot2;
          ((_module_hot1 = module.hot) === null || _module_hot1 === void 0 ? void 0 : _module_hot1.status()) === "fail" || ((_module_hot2 = module.hot) === null || _module_hot2 === void 0 ? void 0 : _module_hot2.status()) === "abort" ? (console.warn(" \u24F5 [hmr] cannot check for update - full reload needed"), console.warn("[hmr]", error), this.app.reload()) : console.warn(" \u24F5 [hmr] update check failed", {
            error
          });
        } finally {
          this.app.LoadingView.hide();
        }
      }
    }
  ]), HMRClient2;
}(), loadHMRClient = function() {
  var { DevSettings, Platform } = require("react-native"), LoadingView = {
    showMessage: function() {
    },
    hide: function() {
    }
  }, reload = function() {
    return DevSettings.reload();
  }, dismissErrors = function() {
    if (Platform.OS === "ios") {
      var _NativeRedBox_dismiss, NativeRedBox = require("react-native/Libraries/NativeModules/specs/NativeRedBox").default;
      NativeRedBox == null || (_NativeRedBox_dismiss = NativeRedBox.dismiss) === null || _NativeRedBox_dismiss === void 0 || _NativeRedBox_dismiss.call(NativeRedBox);
    } else {
      var NativeExceptionsManager = require("react-native/Libraries/Core/NativeExceptionsManager").default;
      NativeExceptionsManager?.dismissRedbox();
    }
    var LogBoxData = require("react-native/Libraries/LogBox/Data/LogBoxData");
    LogBoxData.clear();
  };
  new HMRClient({
    reload,
    dismissErrors,
    LoadingView
  });
};
export {
  loadHMRClient
};
//# sourceMappingURL=hmr-client.js.map
