import prettyFormat from "pretty-format";
import { getDevServerLocation } from "./getDevServerLocation.mjs";
import { loadHMRClient } from "./hmr-client.mjs";
loadHMRClient();
class DevServerClient {
  socket;
  buffer = [];
  constructor() {
    const initSocket = () => {
      const address = `ws://${getDevServerLocation().host}/__client`;
      this.socket = new WebSocket(address);
      const onClose = event => {
        console.warn("Disconnected from the Dev Server:", event.message), this.socket = void 0;
      };
      this.socket.onclose = onClose, this.socket.onerror = onClose, this.socket.onopen = () => {
        this.flushBuffer();
      };
    };
    process.env.NODE_ENV === "development" && initSocket();
  }
  send(level, data) {
    try {
      this.socket?.send(JSON.stringify({
        type: "client-log",
        level,
        data: data.map(item => typeof item == "string" ? item : prettyFormat(item, {
          escapeString: !0,
          highlight: !0,
          maxDepth: 3,
          min: !0,
          plugins: [
          // @ts-expect-error
          prettyFormat.plugins.ReactElement]
        }))
      }));
    } catch {
      try {
        this.socket?.send(JSON.stringify({
          type: "client-log",
          level,
          data: data.map((item, index) => {
            try {
              return typeof item == "string" ? item : JSON.stringify(item);
            } catch (err) {
              return `Error stringifying item at index ${index} - ${item} - ${err}`;
            }
          })
        }));
      } catch (err) {
        try {
          this.socket?.send(JSON.stringify({
            type: "client-log",
            level: "error",
            data: ["error sending client log: " + err]
          }));
        } catch {}
      }
    }
  }
  flushBuffer() {
    globalThis.__vxrnTmpLogs && (globalThis.__vxrnTmpLogs.forEach(({
      level,
      data
    }) => {
      this.buffer.push({
        level,
        data
      });
    }), delete globalThis.__vxrnTmpLogs);
    for (const {
      level,
      data
    } of this.buffer) this.send(level, data);
    this.buffer = [];
  }
  log(level, data) {
    if (level !== "groupEnd") if (this.socket && this.socket.readyState === WebSocket.OPEN) this.flushBuffer(), this.send(level, data);else {
      if (globalThis.__vxrnTmpLogs) return;
      this.buffer.push({
        level,
        data
      });
    }
  }
}
const client = new DevServerClient(),
  setup = () => {},
  enable = () => {},
  disable = () => {},
  registerBundle = () => {},
  log = (level, data) => {
    client.log(level, data);
  };
export { client, disable, enable, log, registerBundle, setup };
//# sourceMappingURL=devServerClient.mjs.map
