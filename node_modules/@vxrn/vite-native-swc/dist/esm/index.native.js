import { transform } from "@swc/core";
import { createRequire } from "node:module";
import { extname } from "node:path";
import { transformGenerators } from "./transformBabel";
var _globalThis_process_versions, _globalThis_process;
function shouldSourceMap() {
  return process.env.VXRN_ENABLE_SOURCE_MAP === "1";
}
var resolve = createRequire(typeof __filename < "u" ? __filename : import.meta.url).resolve, refreshContentRE = /\$Refresh(?:Reg|Sig)\$\(/, isWebContainer = (_globalThis_process = globalThis.process) === null || _globalThis_process === void 0 || (_globalThis_process_versions = _globalThis_process.versions) === null || _globalThis_process_versions === void 0 ? void 0 : _globalThis_process_versions.webcontainer, parsers = {
  ".tsx": {
    syntax: "typescript",
    tsx: !0,
    decorators: !0
  },
  ".ts": {
    syntax: "typescript",
    tsx: !1,
    decorators: !0
  },
  ".jsx": {
    syntax: "ecmascript",
    jsx: !0
  },
  ".js": {
    syntax: "ecmascript"
  },
  // JSX is required to trigger fast refresh transformations, even if MDX already transforms it
  ".mdx": {
    syntax: "ecmascript",
    jsx: !0
  }
}, SWC_ENV = {
  targets: {
    node: "4"
  },
  include: [],
  // this breaks the uniswap app for any file with a ...spread
  exclude: [
    "transform-spread",
    "transform-destructuring",
    "transform-object-rest-spread",
    // `transform-async-to-generator` is relying on `transform-destructuring`.
    // If we exclude `transform-destructuring` but not `transform-async-to-generator`, the SWC binary will panic
    // with error: `called `Option::unwrap()` on a `None` value`.
    // See: https://github.com/swc-project/swc/blob/v1.7.14/crates/swc_ecma_compat_es2015/src/generator.rs#L703-L705
    "transform-async-to-generator",
    "transform-regenerator"
  ]
};
function getParser(id) {
  var forceJSX = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (id.endsWith("one-entry-native"))
    return parsers[".tsx"];
  var extension = extname(id), parser = extension ? parsers[extension] : parsers[".js"];
  return extension === ".js" && (forceJSX && (parser = parsers[".jsx"]), id.includes("expo-modules-core") && (parser = parsers[".jsx"])), parser;
}
function index_default(_options) {
  var hasTransformed = {}, asyncGeneratorRegex = /(async \*|async function\*|for await)/, transformWithoutGenerators = async function(code, id) {
    var parser = getParser(id);
    return hasTransformed[id] = !0, await transform(code, {
      filename: id,
      swcrc: !1,
      configFile: !1,
      sourceMaps: shouldSourceMap(),
      jsc: {
        parser,
        transform: {
          useDefineForClassFields: !0,
          react: {
            development: !0,
            refresh: !1,
            runtime: "automatic"
          }
        }
      },
      env: SWC_ENV
    });
  }, transformWithGenerators = async function(code, id) {
    if (process.env.VXRN_USE_BABEL_FOR_GENERATORS)
      return await transformGenerators(code);
    var parser = getParser(id);
    return hasTransformed[id] = !0, await transform(code, {
      filename: id,
      swcrc: !1,
      configFile: !1,
      sourceMaps: shouldSourceMap(),
      jsc: {
        parser,
        target: "es5",
        transform: {
          useDefineForClassFields: !0,
          react: {
            development: !_options?.production,
            refresh: !1,
            runtime: "automatic"
          }
        }
      }
    });
  }, _options_mode, _options_jsxImportSource, options = {
    mode: (_options_mode = _options?.mode) !== null && _options_mode !== void 0 ? _options_mode : "serve",
    jsxImportSource: (_options_jsxImportSource = _options?.jsxImportSource) !== null && _options_jsxImportSource !== void 0 ? _options_jsxImportSource : "react",
    tsDecorators: _options?.tsDecorators,
    plugins: _options?.plugins ? _options?.plugins.map(function(el) {
      return [
        resolve(el[0]),
        el[1]
      ];
    }) : void 0,
    production: _options?.production
  };
  return [
    {
      name: "vite:react-swc",
      enforce: "pre",
      config: function() {
        var config = {
          esbuild: !1,
          // We only serve bundles for React Native, so optimized deps will not be used anyway.
          optimizeDeps: {
            noDiscovery: !0
          },
          build: {
            // idk why i need both..
            rollupOptions: {
              plugins: [
                {
                  name: "swc-react-native-transform",
                  options: {
                    order: "pre",
                    handler(options2) {
                    }
                  },
                  async transform(code, id) {
                    if (asyncGeneratorRegex.test(code))
                      return await transformWithGenerators(code, id);
                    try {
                      return await transformWithoutGenerators(code, id);
                    } catch (err) {
                      return process.env.DEBUG === "vxrn" && console.error(`${err}`), await transformWithGenerators(code, id);
                    }
                  }
                }
              ]
            }
          }
        };
        return {
          environments: {
            ios: config,
            android: config
          }
        };
      },
      configResolved(config) {
        var mdxIndex = config.plugins.findIndex(function(p) {
          return p.name === "@mdx-js/rollup";
        });
        if (mdxIndex !== -1 && mdxIndex > config.plugins.findIndex(function(p) {
          return p.name === "vite:react-swc";
        }))
          throw new Error("[vite:react-swc] The MDX plugin should be placed before this plugin");
        isWebContainer && config.logger.warn("[vite:react-swc] SWC is currently not supported in WebContainers. You can use the default React plugin instead.");
      },
      async transform(code, _id, transformOptions) {
        if (!hasTransformed[_id] && !_id.includes("virtual:")) {
          if (asyncGeneratorRegex.test(code))
            return await transformWithGenerators(code, _id);
          var out = await swcTransform(_id, code, options);
          return hasTransformed[_id] = !0, out;
        }
      }
    }
  ];
}
async function swcTransform(_id, code, options) {
  var id = _id.split("?")[0].replace(process.cwd(), ""), refresh = options.production || options.noHMR ? !1 : !options.forceJSX, result = await transformWithOptions(id, code, options, {
    refresh,
    development: !options.forceJSX && !options.production,
    runtime: "automatic",
    importSource: options.jsxImportSource
  });
  if (result) {
    if (!refresh || !refreshContentRE.test(result.code))
      return result;
    if (result.code = wrapSourceInRefreshRuntime(id, result.code, options), result.map) {
      var sourceMap = JSON.parse(result.map);
      return sourceMap.mappings = ";;;;;;;;" + sourceMap.mappings, {
        code: result.code,
        map: sourceMap
      };
    }
    return {
      code: result.code
    };
  }
}
var SHARED_MODULE_CONFIG = {
  importInterop: "none"
}, transformWithOptions = async function(id, code, options, reactConfig) {
  var parser = getParser(id, options.forceJSX);
  if (parser) {
    var result;
    try {
      var transformOptions = {
        filename: id,
        swcrc: !1,
        configFile: !1,
        sourceMaps: shouldSourceMap(),
        module: {
          ...SHARED_MODULE_CONFIG,
          type: "nodenext"
        },
        ...options.mode === "serve-cjs" && {
          module: {
            ...SHARED_MODULE_CONFIG,
            type: "commonjs",
            strict: !0
          }
        },
        jsc: {
          parser,
          transform: {
            useDefineForClassFields: !0,
            react: reactConfig
          },
          ...options.forceJSX ? {
            target: "esnext"
          } : {}
        },
        ...options.forceJSX ? {} : {
          env: SWC_ENV
        }
      };
      result = await transform(code, transformOptions);
    } catch (e) {
      return console.info(`SWC failed to transform file, but sometimes this is fine so continuing... Please report: ${id} ${e.message}`), {
        code
      };
    }
    return result;
  }
};
function wrapSourceInRefreshRuntime(id, code, options) {
  var prefixCode = options.mode === "build" ? `
  // ensure it loads react, react native, vite client
  import 'react-native'
  import 'react'
  import '@vxrn/vite-native-client'
  ` : "";
  return options.production ? `
  ${prefixCode}

  module.url = '${id}'

  ${code}
    ` : code.includes("RefreshRuntime = __cachedModules") ? (console.warn("[wrapSourceInRefreshRuntime] detected refresh runtime already in code, skipping"), code) : `const RefreshRuntime = __cachedModules["react-refresh/cjs/react-refresh-runtime.development"];
const prevRefreshReg = globalThis.$RefreshReg$;
const prevRefreshSig = globalThis.$RefreshSig$ || (() => {
  console.info("no react refresh setup!")
  return (x) => x
});
globalThis.$RefreshReg$ = (type, id) => RefreshRuntime.register(type, "${id}" + " " + id);
globalThis.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;

${prefixCode}

module.url = '${id}'
module.hot = createHotContext(module.url)

${code}


if (module.hot) {
  globalThis.$RefreshReg$ = prevRefreshReg;
  globalThis.$RefreshSig$ = prevRefreshSig;
  globalThis['lastHmrExports'] = JSON.stringify(Object.keys(exports))
  if (module.hot.accept) {
    module.hot.accept((nextExports) => {
      RefreshRuntime.performReactRefresh()
    });
  }
}
  `;
}
var transformCommonJs = async function(id, code) {
  var parser = getParser(id);
  if (parser)
    return await transform(code, {
      filename: id,
      swcrc: !1,
      configFile: !1,
      module: {
        type: "commonjs"
      },
      sourceMaps: shouldSourceMap(),
      jsc: {
        target: "es5",
        parser,
        transform: {
          useDefineForClassFields: !0,
          react: {
            development: !0,
            runtime: "automatic"
          }
        }
      }
    });
}, transformForBuild = async function(id, code) {
  var parser = getParser(id);
  if (parser)
    return await transform(code, {
      filename: id,
      swcrc: !1,
      configFile: !1,
      sourceMaps: shouldSourceMap(),
      jsc: {
        target: "es2019",
        parser,
        transform: {
          useDefineForClassFields: !0,
          react: {
            development: !0,
            runtime: "automatic"
          }
        }
      }
    });
};
export {
  index_default as default,
  swcTransform,
  transformCommonJs,
  transformForBuild,
  transformWithOptions
};
//# sourceMappingURL=index.js.map
