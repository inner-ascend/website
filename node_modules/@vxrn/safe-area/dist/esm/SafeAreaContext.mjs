import * as React from "react";
import { Dimensions } from "react-native-web";
import { NativeSafeAreaProvider } from "./NativeSafeAreaProvider.mjs";
import { jsx } from "react/jsx-runtime";
const isDev = process.env.NODE_ENV !== "production",
  SafeAreaInsetsContext = React.createContext(null);
isDev && (SafeAreaInsetsContext.displayName = "SafeAreaInsetsContext");
const SafeAreaFrameContext = React.createContext(null);
isDev && (SafeAreaFrameContext.displayName = "SafeAreaFrameContext");
function SafeAreaProvider({
  children,
  initialMetrics,
  initialSafeAreaInsets,
  ...others
}) {
  const parentInsets = useParentSafeAreaInsets(),
    parentFrame = useParentSafeAreaFrame(),
    [insets, setInsets] = React.useState(initialMetrics?.insets ?? initialSafeAreaInsets ?? parentInsets ?? null),
    [frame, setFrame] = React.useState(initialMetrics?.frame ?? parentFrame ?? {
      // Backwards compat so we render anyway if we don't have frame.
      x: 0,
      y: 0,
      width: Dimensions.get("window").width,
      height: Dimensions.get("window").height
    }),
    onInsetsChange = React.useCallback(event => {
      const {
        nativeEvent: {
          frame: nextFrame,
          insets: nextInsets
        }
      } = event;
      React.startTransition(() => {
        setFrame(curFrame =>
        // Backwards compat with old native code that won't send frame.
        nextFrame && (nextFrame.height !== curFrame.height || nextFrame.width !== curFrame.width || nextFrame.x !== curFrame.x || nextFrame.y !== curFrame.y) ? nextFrame : curFrame), setInsets(curInsets => !curInsets || nextInsets.bottom !== curInsets.bottom || nextInsets.left !== curInsets.left || nextInsets.right !== curInsets.right || nextInsets.top !== curInsets.top ? nextInsets : curInsets);
      });
    }, []);
  return /* @__PURE__ */jsx(NativeSafeAreaProvider, {
    onInsetsChange,
    ...others,
    children: /* @__PURE__ */jsx(SafeAreaFrameContext.Provider, {
      value: frame,
      children: /* @__PURE__ */jsx(SafeAreaInsetsContext.Provider, {
        value: insets,
        children
      })
    })
  });
}
function useParentSafeAreaInsets() {
  return React.useContext(SafeAreaInsetsContext);
}
function useParentSafeAreaFrame() {
  return React.useContext(SafeAreaFrameContext);
}
const NO_INSETS_ERROR = "No safe area value available. Make sure you are rendering `<SafeAreaProvider>` at the top of your app.";
function useSafeAreaInsets() {
  const insets = React.useContext(SafeAreaInsetsContext);
  if (insets == null) throw new Error(NO_INSETS_ERROR);
  return insets;
}
function useSafeAreaFrame() {
  const frame = React.useContext(SafeAreaFrameContext);
  if (frame == null) throw new Error(NO_INSETS_ERROR);
  return frame;
}
function withSafeAreaInsets(WrappedComponent) {
  return React.forwardRef((props, ref) => {
    const insets = useSafeAreaInsets();
    return /* @__PURE__ */jsx(WrappedComponent, {
      ...props,
      insets,
      ref
    });
  });
}
function useSafeArea() {
  return useSafeAreaInsets();
}
const SafeAreaConsumer = SafeAreaInsetsContext.Consumer,
  SafeAreaContext = SafeAreaInsetsContext;
export { SafeAreaConsumer, SafeAreaContext, SafeAreaFrameContext, SafeAreaInsetsContext, SafeAreaProvider, useSafeArea, useSafeAreaFrame, useSafeAreaInsets, withSafeAreaInsets };
//# sourceMappingURL=SafeAreaContext.mjs.map
