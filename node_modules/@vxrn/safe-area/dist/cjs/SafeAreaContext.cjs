var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf,
  __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: !0
    });
  },
  __copyProps = (to, from, except, desc) => {
    if (from && typeof from == "object" || typeof from == "function") for (let key of __getOwnPropNames(from)) !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    });
    return to;
  };
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: !0
  }) : target, mod)),
  __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
    value: !0
  }), mod);
var SafeAreaContext_exports = {};
__export(SafeAreaContext_exports, {
  SafeAreaConsumer: () => SafeAreaConsumer,
  SafeAreaContext: () => SafeAreaContext,
  SafeAreaFrameContext: () => SafeAreaFrameContext,
  SafeAreaInsetsContext: () => SafeAreaInsetsContext,
  SafeAreaProvider: () => SafeAreaProvider,
  useSafeArea: () => useSafeArea,
  useSafeAreaFrame: () => useSafeAreaFrame,
  useSafeAreaInsets: () => useSafeAreaInsets,
  withSafeAreaInsets: () => withSafeAreaInsets
});
module.exports = __toCommonJS(SafeAreaContext_exports);
var React = __toESM(require("react"), 1),
  import_react_native = require("react-native-web"),
  import_NativeSafeAreaProvider = require("./NativeSafeAreaProvider.cjs"),
  import_jsx_runtime = require("react/jsx-runtime");
const isDev = process.env.NODE_ENV !== "production",
  SafeAreaInsetsContext = React.createContext(null);
isDev && (SafeAreaInsetsContext.displayName = "SafeAreaInsetsContext");
const SafeAreaFrameContext = React.createContext(null);
isDev && (SafeAreaFrameContext.displayName = "SafeAreaFrameContext");
function SafeAreaProvider({
  children,
  initialMetrics,
  initialSafeAreaInsets,
  ...others
}) {
  const parentInsets = useParentSafeAreaInsets(),
    parentFrame = useParentSafeAreaFrame(),
    [insets, setInsets] = React.useState(initialMetrics?.insets ?? initialSafeAreaInsets ?? parentInsets ?? null),
    [frame, setFrame] = React.useState(initialMetrics?.frame ?? parentFrame ?? {
      // Backwards compat so we render anyway if we don't have frame.
      x: 0,
      y: 0,
      width: import_react_native.Dimensions.get("window").width,
      height: import_react_native.Dimensions.get("window").height
    }),
    onInsetsChange = React.useCallback(event => {
      const {
        nativeEvent: {
          frame: nextFrame,
          insets: nextInsets
        }
      } = event;
      React.startTransition(() => {
        setFrame(curFrame =>
        // Backwards compat with old native code that won't send frame.
        nextFrame && (nextFrame.height !== curFrame.height || nextFrame.width !== curFrame.width || nextFrame.x !== curFrame.x || nextFrame.y !== curFrame.y) ? nextFrame : curFrame), setInsets(curInsets => !curInsets || nextInsets.bottom !== curInsets.bottom || nextInsets.left !== curInsets.left || nextInsets.right !== curInsets.right || nextInsets.top !== curInsets.top ? nextInsets : curInsets);
      });
    }, []);
  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_NativeSafeAreaProvider.NativeSafeAreaProvider, {
    onInsetsChange,
    ...others,
    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(SafeAreaFrameContext.Provider, {
      value: frame,
      children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(SafeAreaInsetsContext.Provider, {
        value: insets,
        children
      })
    })
  });
}
function useParentSafeAreaInsets() {
  return React.useContext(SafeAreaInsetsContext);
}
function useParentSafeAreaFrame() {
  return React.useContext(SafeAreaFrameContext);
}
const NO_INSETS_ERROR = "No safe area value available. Make sure you are rendering `<SafeAreaProvider>` at the top of your app.";
function useSafeAreaInsets() {
  const insets = React.useContext(SafeAreaInsetsContext);
  if (insets == null) throw new Error(NO_INSETS_ERROR);
  return insets;
}
function useSafeAreaFrame() {
  const frame = React.useContext(SafeAreaFrameContext);
  if (frame == null) throw new Error(NO_INSETS_ERROR);
  return frame;
}
function withSafeAreaInsets(WrappedComponent) {
  return React.forwardRef((props, ref) => {
    const insets = useSafeAreaInsets();
    return /* @__PURE__ */(0, import_jsx_runtime.jsx)(WrappedComponent, {
      ...props,
      insets,
      ref
    });
  });
}
function useSafeArea() {
  return useSafeAreaInsets();
}
const SafeAreaConsumer = SafeAreaInsetsContext.Consumer,
  SafeAreaContext = SafeAreaInsetsContext;