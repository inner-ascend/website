import getDevServer from "react-native/Libraries/Core/Devtools/getDevServer";
const importMetaUrl = {
    hostname: "127.0.0.1",
    protocol: "http",
    port: 5173
  },
  serverHost = __SERVER_HOST__,
  socketProtocol = __HMR_PROTOCOL__ || (importMetaUrl.protocol === "https:" ? "wss" : "ws"),
  hmrPort = __HMR_PORT__ || 5173;
let rnDevServerHost;
try {
  const {
      url: devServerUrl
    } = getDevServer(),
    [, host] = devServerUrl.match(/:\/\/([^\/]+)/) || [];
  host && (rnDevServerHost = host);
} catch (e) {
  console.warn(`[vite-native-client] failed to get react-native dev server url: ${e}`);
}
const hmrHost = rnDevServerHost || `${__HMR_HOSTNAME__ || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}`,
  socketHost = `${hmrHost}${__HMR_BASE__}`,
  directSocketHost = __HMR_DIRECT_TARGET__,
  base = __BASE__ || "/",
  messageBuffer = [];
let socket;
try {
  let fallback;
  hmrPort || (fallback = () => {
    socket = setupWebSocket(socketProtocol, directSocketHost, () => {
      console.error(`[vite] failed to connect to websocket.
your current setup:
  (browser) ${JSON.stringify(importMetaUrl)} <--[HTTP]--> ${serverHost} (server)
  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)
Check out your Vite / network configuration and https://vitejs.dev/config/server-options.html#server-hmr .`);
    }), socket.addEventListener("open", () => {
      console.info("[vite] Direct websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.");
    }, {
      once: !0
    });
  }), socket = setupWebSocket(socketProtocol, socketHost, fallback);
} catch (error) {
  console.error(`[vite] failed to connect to websocket (${error}). `);
}
function setupWebSocket(protocol, hostAndPath, onCloseWithoutOpen) {
  const endpoint = `${protocol}://${hostAndPath}`,
    socket2 = new WebSocket(endpoint, "vite-hmr");
  let isOpened = !1;
  return socket2.addEventListener("open", () => {
    isOpened = !0, notifyListeners("vite:ws:connect", {
      webSocket: socket2
    });
  }, {
    once: !0
  }), socket2.addEventListener("message", ({
    data
  }) => {
    process.env.DEBUG && console.info(" \u2776 hmr ", data), handleMessage(JSON.parse(data));
  }), socket2.addEventListener("error", err => {
    console.info("err" + err.message + err.stack);
  }), socket2.addEventListener("close", ({
    wasClean
  }) => {
    if (!wasClean) {
      if (!isOpened && onCloseWithoutOpen) {
        onCloseWithoutOpen();
        return;
      }
      notifyListeners("vite:ws:disconnect", {
        webSocket: socket2
      }), console.info("[vite] server connection lost. polling for restart..."), waitForSuccessfulPing(protocol, hostAndPath).then(() => {
        console.info("should reload");
      });
    }
  }), socket2;
}
function warnFailedFetch(err, path2) {
  try {
    console.error(`${err.message}
${err.stack}`);
  } catch {
    console.error(`${err}`);
  }
  console.error(`[hmr] Failed to reload ${path2}. This could be due to syntax errors or importing non-existent modules. (see errors above)`);
}
let isFirstUpdate = !0;
const debounceReload = time => {
    let timer;
    return () => {
      timer && (clearTimeout(timer), timer = null), timer = setTimeout(() => {
        globalThis.__vxrnReloadApp();
      }, time);
    };
  },
  pageReload = debounceReload(50);
async function handleMessage(payload) {
  switch (payload.type) {
    case "connected":
      console.info("[vite] connected."), sendMessageBuffer(), setInterval(() => {
        socket.readyState === socket.OPEN && socket.send('{"type":"ping"}');
      }, __HMR_TIMEOUT__);
      break;
    case "update":
      if (notifyListeners("vite:beforeUpdate", payload), isFirstUpdate && hasErrorOverlay()) {
        globalThis.__vxrnReloadApp();
        return;
      }
      isFirstUpdate = !1, await Promise.all(payload.updates.map(update => {
        if (update.type === "js-update") return queueUpdate(fetchUpdate(update));
      })), notifyListeners("vite:afterUpdate", payload);
      break;
    case "custom":
      {
        notifyListeners(payload.event, payload.data);
        break;
      }
    case "full-reload":
      if (notifyListeners("vite:beforeFullReload", payload), payload.path && payload.path.endsWith(".html")) {
        const pagePath = decodeURI(location.pathname),
          payloadPath = base + payload.path.slice(1);
        (pagePath === payloadPath || payload.path === "/index.html" || pagePath.endsWith("/") && pagePath + "index.html" === payloadPath) && pageReload();
        return;
      }
      pageReload();
      break;
    case "prune":
      notifyListeners("vite:beforePrune", payload), payload.paths.forEach(path2 => {
        const fn = pruneMap.get(path2);
        fn && fn(dataMap.get(path2));
      });
      break;
    case "error":
      {
        notifyListeners("vite:error", payload);
        const err = payload.err;
        enableOverlay ? createErrorOverlay(err) : console.error(`[vite] Internal Server Error
${err.message}
${err.stack}`);
        break;
      }
    default:
      return payload;
  }
}
function notifyListeners(event, data) {
  const cbs = customListenersMap.get(event);
  cbs && cbs.forEach(cb => cb(data));
}
const enableOverlay = __HMR_ENABLE_OVERLAY__;
function createErrorOverlay(err) {
  enableOverlay && console.error("create error", err);
}
function clearErrorOverlay() {}
function hasErrorOverlay() {
  return !1;
}
let pending = !1,
  queued = [];
async function queueUpdate(p) {
  if (queued.push(p), !pending) {
    pending = !0, await Promise.resolve(), pending = !1;
    const loading = [...queued];
    queued = [], (await Promise.all(loading)).forEach(fn => fn && fn());
  }
}
async function waitForSuccessfulPing(socketProtocol2, hostAndPath, ms = 1e3) {
  const pingHostProtocol = socketProtocol2 === "wss" ? "https" : "http",
    ping = async () => {
      try {
        return await fetch(`${pingHostProtocol}://${hostAndPath}`, {
          mode: "no-cors",
          headers: {
            // Custom headers won't be included in a request with no-cors so (ab)use one of the
            // safelisted headers to identify the ping request
            Accept: "text/x-vite-ping"
          }
        }), !0;
      } catch {}
      return !1;
    };
  if (!(await ping())) for (await wait(ms); !(await ping());) await wait(ms);
}
function wait(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
async function fetchUpdate({
  path: pathIn,
  acceptedPath: acceptedPathIn,
  timestamp,
  explicitImportRequired
}) {
  const path = pathIn.replace("/@id", ""),
    acceptedPath = acceptedPathIn.replace("/@id", ""),
    mod = hotModulesMap.get(path);
  if (!mod) {
    console.info(" \u2776 hmr - No module found"), console.info(`    looked for ${path} in:`), hotModulesMap.forEach((value, key) => {
      console.info(`   - ${key}`);
    });
    return;
  }
  let fetchedModule;
  const isSelfUpdate = path === acceptedPath,
    qualifiedCallbacks = mod.callbacks.filter(({
      deps
    }) => deps.includes(acceptedPath));
  if (isSelfUpdate || qualifiedCallbacks.length > 0) {
    const disposer = disposeMap.get(acceptedPath);
    disposer && (await disposer(dataMap.get(acceptedPath)));
    const [acceptedPathWithoutQuery, query] = acceptedPath.split("?");
    try {
      const filePath = acceptedPathWithoutQuery,
        finalQuery = `file?file=${encodeURIComponent(filePath)}&${explicitImportRequired ? "import&" : ""}t=${timestamp}${query ? `&${query}` : ""}`,
        scriptUrl =
        // re-route to our cjs endpoint
        `http://${rnDevServerHost ? rnDevServerHost + "/" : serverHost.replace("5173", "8081")}` + finalQuery;
      console.info(` \u2776 hmr fetching update: ${scriptUrl}`);
      const source = await fetch(scriptUrl).then(res => res.text()),
        evaluatedModule = eval(source);
      fetchedModule = evaluatedModule;
    } catch (e) {
      warnFailedFetch(e, acceptedPath);
    }
  } else console.info(` \u2776 hmr can't accept - isSelfUpdate ${isSelfUpdate} - callbacks: ${JSON.stringify(mod.callbacks)} - acceptedPath: ${acceptedPath}`);
  return () => {
    for (const {
      deps,
      fn
    } of qualifiedCallbacks) fn(deps.map(dep => dep === acceptedPath ? fetchedModule : void 0));
    const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;
    process.env.DEBUG && console.info(`[vite] hot updated: ${loggedPath}`);
  };
}
function sendMessageBuffer() {
  socket.readyState === 1 && (messageBuffer.forEach(msg => socket.send(msg)), messageBuffer.length = 0);
}
const hotModulesMap = /* @__PURE__ */new Map(),
  disposeMap = /* @__PURE__ */new Map(),
  pruneMap = /* @__PURE__ */new Map(),
  dataMap = /* @__PURE__ */new Map(),
  customListenersMap = /* @__PURE__ */new Map(),
  ctxToListenersMap = /* @__PURE__ */new Map();
globalThis.createHotContext = function createHotContext(ownerPath) {
  dataMap.has(ownerPath) || dataMap.set(ownerPath, {});
  const mod2 = hotModulesMap.get(ownerPath);
  mod2 && (mod2.callbacks = []);
  const staleListeners = ctxToListenersMap.get(ownerPath);
  if (staleListeners) for (const [event, staleFns] of staleListeners) {
    const listeners = customListenersMap.get(event);
    listeners && customListenersMap.set(event, listeners.filter(l => !staleFns.includes(l)));
  }
  const newListeners = /* @__PURE__ */new Map();
  ctxToListenersMap.set(ownerPath, newListeners);
  function acceptDeps(deps, callback = () => {}) {
    const mod3 = hotModulesMap.get(ownerPath) || {
      id: ownerPath,
      callbacks: []
    };
    mod3.callbacks.push({
      deps,
      fn: callback
    }), hotModulesMap.set(ownerPath, mod3);
  }
  return {
    get data() {
      return dataMap.get(ownerPath);
    },
    accept(deps, callback) {
      if (typeof deps == "function" || !deps) acceptDeps([ownerPath], ([mod3]) => deps?.(mod3));else if (typeof deps == "string") acceptDeps([deps], ([mod3]) => callback?.(mod3));else if (Array.isArray(deps)) acceptDeps(deps, callback);else throw new Error("invalid hot.accept() usage.");
    },
    // export names (first arg) are irrelevant on the client side, they're
    // extracted in the server for propagation
    acceptExports(_, callback) {
      acceptDeps([ownerPath], ([mod3]) => callback?.(mod3));
    },
    dispose(cb) {
      disposeMap.set(ownerPath, cb);
    },
    prune(cb) {
      pruneMap.set(ownerPath, cb);
    },
    // Kept for backward compatibility (#11036)
    // @ts-expect-error untyped
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    decline() {},
    // tell the server to re-perform hmr propagation from this module as root
    invalidate(message) {
      notifyListeners("vite:invalidate", {
        path: ownerPath,
        message
      }), this.send("vite:invalidate", {
        path: ownerPath,
        message
      }), console.info(`[vite] invalidate ${ownerPath}${message ? `: ${message}` : ""}`);
    },
    // custom events
    on(event, cb) {
      const addToMap = map => {
        const existing = map.get(event) || [];
        existing.push(cb), map.set(event, existing);
      };
      addToMap(customListenersMap), addToMap(newListeners);
    },
    send(event, data) {
      messageBuffer.push(JSON.stringify({
        type: "custom",
        event,
        data
      })), sendMessageBuffer();
    }
  };
};
//# sourceMappingURL=client.mjs.map
