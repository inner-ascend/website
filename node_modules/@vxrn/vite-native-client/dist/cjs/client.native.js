"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: !0 }) : target,
  mod2
));
var import_getDevServer = __toESM(require("react-native/Libraries/Core/Devtools/getDevServer")), importMetaUrl = {
  hostname: "127.0.0.1",
  protocol: "http",
  port: 5173
}, serverHost = __SERVER_HOST__, socketProtocol = __HMR_PROTOCOL__ || (importMetaUrl.protocol === "https:" ? "wss" : "ws"), hmrPort = __HMR_PORT__ || 5173, rnDevServerHost;
try {
  var { url: devServerUrl } = (0, import_getDevServer.default)(), [, host] = devServerUrl.match(/:\/\/([^\/]+)/) || [];
  host && (rnDevServerHost = host);
} catch (e) {
  console.warn(`[vite-native-client] failed to get react-native dev server url: ${e}`);
}
var hmrHost = rnDevServerHost || `${__HMR_HOSTNAME__ || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}`, socketHost = `${hmrHost}${__HMR_BASE__}`, directSocketHost = __HMR_DIRECT_TARGET__, base = __BASE__ || "/", messageBuffer = [], socket;
try {
  var fallback;
  hmrPort || (fallback = function() {
    socket = setupWebSocket(socketProtocol, directSocketHost, function() {
      console.error(`[vite] failed to connect to websocket.
your current setup:
  (browser) ${JSON.stringify(importMetaUrl)} <--[HTTP]--> ${serverHost} (server)
  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)
Check out your Vite / network configuration and https://vitejs.dev/config/server-options.html#server-hmr .`);
    }), socket.addEventListener("open", function() {
      console.info("[vite] Direct websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.");
    }, {
      once: !0
    });
  }), socket = setupWebSocket(socketProtocol, socketHost, fallback);
} catch (error) {
  console.error(`[vite] failed to connect to websocket (${error}). `);
}
function setupWebSocket(protocol, hostAndPath, onCloseWithoutOpen) {
  var endpoint = `${protocol}://${hostAndPath}`, socket1 = new WebSocket(endpoint, "vite-hmr"), isOpened = !1;
  return socket1.addEventListener("open", function() {
    isOpened = !0, notifyListeners("vite:ws:connect", {
      webSocket: socket1
    });
  }, {
    once: !0
  }), socket1.addEventListener("message", function(param2) {
    var { data } = param2;
    process.env.DEBUG && console.info(" \u2776 hmr ", data), handleMessage(JSON.parse(data));
  }), socket1.addEventListener("error", function(err) {
    console.info("err" + err.message + err.stack);
  }), socket1.addEventListener("close", function(param2) {
    var { wasClean } = param2;
    if (!wasClean) {
      if (!isOpened && onCloseWithoutOpen) {
        onCloseWithoutOpen();
        return;
      }
      notifyListeners("vite:ws:disconnect", {
        webSocket: socket1
      }), console.info("[vite] server connection lost. polling for restart..."), waitForSuccessfulPing(protocol, hostAndPath).then(function() {
        console.info("should reload");
      });
    }
  }), socket1;
}
function warnFailedFetch(err, path2) {
  try {
    console.error(`${err.message}
${err.stack}`);
  } catch {
    console.error(`${err}`);
  }
  console.error(`[hmr] Failed to reload ${path2}. This could be due to syntax errors or importing non-existent modules. (see errors above)`);
}
var isFirstUpdate = !0, debounceReload = function(time) {
  var timer;
  return function() {
    timer && (clearTimeout(timer), timer = null), timer = setTimeout(function() {
      globalThis.__vxrnReloadApp();
    }, time);
  };
}, pageReload = debounceReload(50);
async function handleMessage(payload) {
  switch (payload.type) {
    case "connected":
      console.info("[vite] connected."), sendMessageBuffer(), setInterval(function() {
        socket.readyState === socket.OPEN && socket.send('{"type":"ping"}');
      }, __HMR_TIMEOUT__);
      break;
    case "update":
      if (notifyListeners("vite:beforeUpdate", payload), isFirstUpdate && hasErrorOverlay()) {
        globalThis.__vxrnReloadApp();
        return;
      }
      isFirstUpdate = !1, await Promise.all(payload.updates.map(function(update) {
        if (update.type === "js-update")
          return queueUpdate(fetchUpdate(update));
      })), notifyListeners("vite:afterUpdate", payload);
      break;
    case "custom": {
      notifyListeners(payload.event, payload.data);
      break;
    }
    case "full-reload":
      if (notifyListeners("vite:beforeFullReload", payload), payload.path && payload.path.endsWith(".html")) {
        var pagePath = decodeURI(location.pathname), payloadPath = base + payload.path.slice(1);
        (pagePath === payloadPath || payload.path === "/index.html" || pagePath.endsWith("/") && pagePath + "index.html" === payloadPath) && pageReload();
        return;
      }
      pageReload();
      break;
    case "prune":
      notifyListeners("vite:beforePrune", payload), payload.paths.forEach(function(path2) {
        var fn = pruneMap.get(path2);
        fn && fn(dataMap.get(path2));
      });
      break;
    case "error": {
      notifyListeners("vite:error", payload);
      var err = payload.err;
      enableOverlay ? createErrorOverlay(err) : console.error(`[vite] Internal Server Error
${err.message}
${err.stack}`);
      break;
    }
    default: {
      var check = payload;
      return check;
    }
  }
}
function notifyListeners(event, data) {
  var cbs = customListenersMap.get(event);
  cbs && cbs.forEach(function(cb) {
    return cb(data);
  });
}
var enableOverlay = __HMR_ENABLE_OVERLAY__;
function createErrorOverlay(err) {
  enableOverlay && console.error("create error", err);
}
function clearErrorOverlay() {
}
function hasErrorOverlay() {
  return !1;
}
var pending = !1, queued = [];
async function queueUpdate(p) {
  if (queued.push(p), !pending) {
    pending = !0, await Promise.resolve(), pending = !1;
    var loading = [
      ...queued
    ];
    queued = [], (await Promise.all(loading)).forEach(function(fn) {
      return fn && fn();
    });
  }
}
async function waitForSuccessfulPing(socketProtocol1, hostAndPath) {
  var ms = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e3, pingHostProtocol = socketProtocol1 === "wss" ? "https" : "http", ping = async function() {
    try {
      return await fetch(`${pingHostProtocol}://${hostAndPath}`, {
        mode: "no-cors",
        headers: {
          // Custom headers won't be included in a request with no-cors so (ab)use one of the
          // safelisted headers to identify the ping request
          Accept: "text/x-vite-ping"
        }
      }), !0;
    } catch {
    }
    return !1;
  };
  if (!await ping())
    for (await wait(ms); !await ping(); )
      await wait(ms);
}
function wait(ms) {
  return new Promise(function(resolve) {
    return setTimeout(resolve, ms);
  });
}
async function fetchUpdate(param) {
  var { path: pathIn, acceptedPath: acceptedPathIn, timestamp, explicitImportRequired } = param, path = pathIn.replace("/@id", ""), acceptedPath = acceptedPathIn.replace("/@id", ""), mod = hotModulesMap.get(path);
  if (!mod) {
    console.info(" \u2776 hmr - No module found"), console.info(`    looked for ${path} in:`), hotModulesMap.forEach(function(value, key) {
      console.info(`   - ${key}`);
    });
    return;
  }
  var fetchedModule, isSelfUpdate = path === acceptedPath, qualifiedCallbacks = mod.callbacks.filter(function(param2) {
    var { deps } = param2;
    return deps.includes(acceptedPath);
  });
  if (isSelfUpdate || qualifiedCallbacks.length > 0) {
    var disposer = disposeMap.get(acceptedPath);
    disposer && await disposer(dataMap.get(acceptedPath));
    var [acceptedPathWithoutQuery, query] = acceptedPath.split("?");
    try {
      var filePath = acceptedPathWithoutQuery, finalQuery = `file?file=${encodeURIComponent(filePath)}&${explicitImportRequired ? "import&" : ""}t=${timestamp}${query ? `&${query}` : ""}`, scriptUrl = (
        // re-route to our cjs endpoint
        `http://${rnDevServerHost ? rnDevServerHost + "/" : serverHost.replace("5173", "8081")}` + finalQuery
      );
      console.info(` \u2776 hmr fetching update: ${scriptUrl}`);
      var source = await fetch(scriptUrl).then(function(res) {
        return res.text();
      }), evaluatedModule = eval(source);
      fetchedModule = evaluatedModule;
    } catch (e) {
      warnFailedFetch(e, acceptedPath);
    }
  } else
    console.info(` \u2776 hmr can't accept - isSelfUpdate ${isSelfUpdate} - callbacks: ${JSON.stringify(mod.callbacks)} - acceptedPath: ${acceptedPath}`);
  return function() {
    var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
    try {
      for (var _iterator = qualifiedCallbacks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
        var { deps, fn } = _step.value;
        fn(deps.map(function(dep) {
          return dep === acceptedPath ? fetchedModule : void 0;
        }));
      }
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError)
          throw _iteratorError;
      }
    }
    var loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;
    process.env.DEBUG && console.info(`[vite] hot updated: ${loggedPath}`);
  };
}
function sendMessageBuffer() {
  socket.readyState === 1 && (messageBuffer.forEach(function(msg) {
    return socket.send(msg);
  }), messageBuffer.length = 0);
}
var hotModulesMap = /* @__PURE__ */ new Map(), disposeMap = /* @__PURE__ */ new Map(), pruneMap = /* @__PURE__ */ new Map(), dataMap = /* @__PURE__ */ new Map(), customListenersMap = /* @__PURE__ */ new Map(), ctxToListenersMap = /* @__PURE__ */ new Map();
globalThis.createHotContext = function createHotContext(ownerPath) {
  dataMap.has(ownerPath) || dataMap.set(ownerPath, {});
  var mod2 = hotModulesMap.get(ownerPath);
  mod2 && (mod2.callbacks = []);
  var staleListeners = ctxToListenersMap.get(ownerPath);
  if (staleListeners) {
    var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
    try {
      for (var _loop = function() {
        var [event, staleFns] = _step.value, listeners = customListenersMap.get(event);
        listeners && customListenersMap.set(event, listeners.filter(function(l) {
          return !staleFns.includes(l);
        }));
      }, _iterator = staleListeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) _loop();
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError)
          throw _iteratorError;
      }
    }
  }
  var newListeners = /* @__PURE__ */ new Map();
  ctxToListenersMap.set(ownerPath, newListeners);
  function acceptDeps(deps) {
    var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
    }, mod3 = hotModulesMap.get(ownerPath) || {
      id: ownerPath,
      callbacks: []
    };
    mod3.callbacks.push({
      deps,
      fn: callback
    }), hotModulesMap.set(ownerPath, mod3);
  }
  var hot = {
    get data() {
      return dataMap.get(ownerPath);
    },
    accept(deps, callback) {
      if (typeof deps == "function" || !deps)
        acceptDeps([
          ownerPath
        ], function(param2) {
          var [mod3] = param2;
          return deps == null ? void 0 : deps(mod3);
        });
      else if (typeof deps == "string")
        acceptDeps([
          deps
        ], function(param2) {
          var [mod3] = param2;
          return callback == null ? void 0 : callback(mod3);
        });
      else if (Array.isArray(deps))
        acceptDeps(deps, callback);
      else
        throw new Error("invalid hot.accept() usage.");
    },
    // export names (first arg) are irrelevant on the client side, they're
    // extracted in the server for propagation
    acceptExports(_, callback) {
      acceptDeps([
        ownerPath
      ], function(param2) {
        var [mod3] = param2;
        return callback == null ? void 0 : callback(mod3);
      });
    },
    dispose(cb) {
      disposeMap.set(ownerPath, cb);
    },
    prune(cb) {
      pruneMap.set(ownerPath, cb);
    },
    // Kept for backward compatibility (#11036)
    // @ts-expect-error untyped
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    decline() {
    },
    // tell the server to re-perform hmr propagation from this module as root
    invalidate(message) {
      notifyListeners("vite:invalidate", {
        path: ownerPath,
        message
      }), this.send("vite:invalidate", {
        path: ownerPath,
        message
      }), console.info(`[vite] invalidate ${ownerPath}${message ? `: ${message}` : ""}`);
    },
    // custom events
    on(event, cb) {
      var addToMap = function(map) {
        var existing = map.get(event) || [];
        existing.push(cb), map.set(event, existing);
      };
      addToMap(customListenersMap), addToMap(newListeners);
    },
    send(event, data) {
      messageBuffer.push(JSON.stringify({
        type: "custom",
        event,
        data
      })), sendMessageBuffer();
    }
  };
  return hot;
};
//# sourceMappingURL=client.js.map
