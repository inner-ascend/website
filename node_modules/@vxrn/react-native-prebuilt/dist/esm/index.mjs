import { readFile } from "node:fs/promises";
import { mustReplace } from "@vxrn/utils";
import { transformFlow } from "@vxrn/vite-flow";
import { build } from "esbuild";
import FSExtra from "fs-extra";
import { createRequire } from "node:module";
const requireResolve = "url" in import.meta ? createRequire(import.meta.url).resolve : require.resolve,
  external = ["react", "react/jsx-runtime", "react/jsx-dev-runtime"];
async function buildReactJSX(options = {}) {
  const isProd = options.define?.__DEV__ === "false";
  return build({
    bundle: !0,
    entryPoints: [requireResolve("react/jsx-dev-runtime")],
    format: "cjs",
    target: "node16",
    jsx: "transform",
    jsxFactory: "react",
    allowOverwrite: !0,
    platform: "node",
    define: {
      __DEV__: "true",
      "process.env.NODE_ENV": '"development"'
    },
    external,
    logLevel: "warning",
    ...options
  }).then(async () => {
    const bundled = await readFile(options.outfile, "utf-8"),
      outCode = `
    const run = () => {
      ${mustReplace(bundled, [isProd ? {
        find: "module.exports = require_react_jsx_runtime_production_min();",
        replace: "return require_react_jsx_runtime_production_min();"
      } : {
        find: "module.exports = require_react_jsx_dev_runtime_development();",
        replace: "return require_react_jsx_dev_runtime_development();"
      }, {
        find: "process.env.VXRN_REACT_19",
        replace: "false",
        optional: !0
      }, {
        find: `Object.assign(exports, eval("require('@vxrn/vendor/react-jsx-19')"));`,
        optional: !0,
        replace: ""
      }])}
    }
    const __mod__ = run()
    ${["jsx", "jsxs", "jsxDEV", "Fragment"].map(n => `export const ${n} = __mod__.${n} || __mod__.jsx || ${n === "jsxs" ? "function (type, props, key) { return __mod__.jsxDEV(type, props, key, true) }" : "__mod__.jsxDEV"}`).join(`
`)}
    `;
    await FSExtra.writeFile(options.outfile, outCode);
  });
}
async function buildReact(options = {}) {
  const isProd = options.define?.__DEV__ === "false";
  return build({
    bundle: !0,
    entryPoints: [requireResolve("react")],
    format: "cjs",
    target: "node16",
    jsx: "transform",
    jsxFactory: "react",
    allowOverwrite: !0,
    platform: "node",
    define: {
      __DEV__: "true",
      "process.env.NODE_ENV": '"development"'
    },
    logLevel: "warning",
    external,
    ...options
  }).then(async () => {
    const bundled = await readFile(options.outfile, "utf-8"),
      outCode = `
    const run = () => {
      ${mustReplace(bundled, [isProd ? {
        find: /module\.exports = require_react_production_min(\d*)\(\);/,
        replace: "return require_react_production_min$1();"
      } : {
        find: /module\.exports = require_react_development(\d*)\(\);/,
        replace: "return require_react_development$1();"
      }, {
        find: "process.env.VXRN_REACT_19",
        optional: !0,
        replace: "false"
      }, {
        find: `Object.assign(exports, eval("require('@vxrn/vendor/react-19')"));`,
        optional: !0,
        replace: ""
      }])}
    }
    const __mod__ = run()
    ${RExports.map(n => `export const ${n} = __mod__.${n}`).join(`
`)}
    export default __mod__
    `;
    await FSExtra.writeFile(options.outfile, outCode);
  });
}
async function buildReactNative(options = {}, {
  platform
}) {
  return build({
    bundle: !0,
    entryPoints: [requireResolve("react-native")],
    format: "cjs",
    target: "node20",
    // Note: JSX is actually being transformed by the "remove-flow" plugin defined underneath, not by esbuild. The following JSX options may not actually make a difference.
    jsx: "transform",
    jsxFactory: "react",
    allowOverwrite: !0,
    platform: "node",
    external,
    loader: {
      ".png": "dataurl",
      ".jpg": "dataurl",
      ".jpeg": "dataurl",
      ".gif": "dataurl"
    },
    define: {
      __DEV__: "true",
      "process.env.NODE_ENV": '"development"'
    },
    logLevel: "warning",
    resolveExtensions: [`.${platform}.js`, ".native.js", ".native.ts", ".native.tsx", ".js", ".jsx", ".json", ".ts", ".tsx", ".mjs"],
    ...options,
    plugins: [{
      name: "remove-flow",
      setup(build2) {
        build2.onResolve({
          filter: /HMRClient/
        }, async input => {
          const path = requireResolve("@vxrn/vite-native-hmr"),
            possibleEsmPath = path.replace("/cjs/index.cjs", "/esm/index.native.js");
          return FSExtra.pathExistsSync(possibleEsmPath) ? {
            path: possibleEsmPath
          } : {
            path
          };
        }), build2.onLoad({
          filter: /.*\.js$/
        }, async input => {
          if (!input.path.includes("react-native") && !input.path.includes("vite-native-hmr")) return;
          const code = await readFile(input.path, "utf-8");
          return {
            contents: await transformFlow(code, {
              development: !0
            }),
            loader: "jsx"
          };
        });
      }
    }]
  }).then(async () => {
    const bundled = await readFile(options.outfile, "utf-8"),
      outCode = `
    const run = () => {
      ${mustReplace(bundled, [{
        find: esbuildCommonJSFunction,
        replace: `
// replaced commonjs function to allow importing internals
var __commonJS = function __commonJS(cb, mod) {
    var path = __getOwnPropNames(cb)[0];
    var modulePath = path.replace(/.*node_modules\\//, '').replace('.js', '');

    var __require = function __require() {
        if (mod) return mod;

        var cachedMod = globalThis["__cachedModules"][modulePath];
        if (cachedMod) return cachedMod;

        var moduleFn = cb[path];
        mod = {
            exports: {}
        };
        moduleFn(mod.exports, mod);
        mod = mod.exports;
        // this is one of our patches basically allowing importing the inner contents:
        globalThis["__cachedModules"][modulePath] = mod;
        return mod;
    };

    // this is another patch basically allowing importing the inner contents:
    if (globalThis['__RN_INTERNAL_MODULE_REQUIRES_MAP__']) {
        globalThis['__RN_INTERNAL_MODULE_REQUIRES_MAP__'][modulePath] = __require;
    }

    return __require;
};
`
      }, {
        find: "module.exports = require_react_native();",
        replace: "return require_react_native();"
      },
      // Export `@react-native/assets-registry/registry`
      {
        find: "return require_react_native();",
        replace: ["const rn = require_react_native();", "rn.AssetRegistry = require_registry();", "require_ReactNative();",
        // This is react-native/Libraries/Renderer/shims/ReactNative.js, we call it here to ensure shims are initialized since we won't lazy load React Native components. See the NOTE below.
        "if (typeof require_InitializeCore === 'function') { require_InitializeCore(); }",
        // Since we're accessing the RefreshRuntime directly via `__cachedModules` directly in the RN bundle, we need to ensure it's loaded in time. Note that calling `require_react_refresh_runtime_development()`, `require_setUpReactRefresh()` or `require_setUpDeveloperTools()` directly won't work.
        "return rn;"].join(`
`)
      }])}
    }
    const RN = run()

    export const REACT_NATIVE_ESM_MANUAL_EXPORTS_START = 'REACT_NATIVE_ESM_MANUAL_EXPORTS_START';
    ${RNExportNames.map(n => `export const ${n} = RN.${n}`).join(`
`)}
    export const REACT_NATIVE_ESM_MANUAL_EXPORTS_END = 'REACT_NATIVE_ESM_MANUAL_EXPORTS_END';
    `;
    await FSExtra.writeFile(options.outfile, outCode);
  });
}
const esbuildCommonJSFunction = `var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};`,
  RNExportNames = ["registerCallableModule", "AccessibilityInfo", "ActivityIndicator", "Button", "DrawerLayoutAndroid", "FlatList", "Image", "ImageBackground", "InputAccessoryView", "KeyboardAvoidingView", "Modal", "Pressable", "RefreshControl", "SafeAreaView", "ScrollView", "SectionList", "StatusBar", "Switch", "Text", "TextInput", "Touchable", "TouchableHighlight", "TouchableNativeFeedback", "TouchableOpacity", "TouchableWithoutFeedback", "View", "VirtualizedList", "VirtualizedSectionList", "ActionSheetIOS", "Alert", "Animated", "Appearance", "AppRegistry", "AppState", "BackHandler", "DeviceInfo", "DevSettings", "Dimensions", "Easing", "findNodeHandle", "I18nManager", "InteractionManager", "Keyboard", "LayoutAnimation", "Linking", "LogBox", "NativeDialogManagerAndroid", "NativeEventEmitter", "Networking", "PanResponder", "PermissionsAndroid", "PixelRatio", "Settings", "Share", "StyleSheet", "Systrace", "ToastAndroid", "TurboModuleRegistry", "UIManager", "unstable_batchedUpdates", "useAnimatedValue", "useColorScheme", "useWindowDimensions", "UTFSequence", "Vibration", "YellowBox", "DeviceEventEmitter", "DynamicColorIOS", "NativeAppEventEmitter", "NativeModules", "Platform", "PlatformColor", "processColor", "requireNativeComponent", "RootTagContext", "unstable_enableLogBox", "AssetRegistry"
  // Normally not exported by React Native, but with a hack we make @react-native/assets-registry/registry available here.
  ],
  RExports = ["Children", "Component", "Fragment", "Profiler", "PureComponent", "StrictMode", "Suspense", "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", "cloneElement", "createContext", "createElement", "createFactory", "createRef", "forwardRef", "isValidElement", "lazy", "memo", "startTransition", "unstable_act", "useCallback", "useContext", "useDebugValue", "useDeferredValue", "useEffect", "useId", "useImperativeHandle", "useInsertionEffect", "useLayoutEffect", "useMemo", "useReducer", "useRef", "useState", "useSyncExternalStore", "useTransition", "version"];
export { buildReact, buildReactJSX, buildReactNative };
//# sourceMappingURL=index.mjs.map
