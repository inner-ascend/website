'use strict';

/**
 * @license bippy
 *
 * Copyright (c) Aiden Bai.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// src/index.ts
var version = "0.0.25";
var BIPPY_INSTRUMENTATION_STRING = `bippy-${version}`;
var ClassComponentTag = 1;
var FunctionComponentTag = 0;
var ContextConsumerTag = 9;
var SuspenseComponentTag = 13;
var OffscreenComponentTag = 22;
var ForwardRefTag = 11;
var MemoComponentTag = 14;
var SimpleMemoComponentTag = 15;
var HostComponentTag = 5;
var HostHoistableTag = 26;
var HostSingletonTag = 27;
var DehydratedSuspenseComponent = 18;
var HostText = 6;
var Fragment = 7;
var LegacyHiddenComponent = 23;
var OffscreenComponent = 22;
var HostRoot = 3;
var CONCURRENT_MODE_NUMBER = 60111;
var CONCURRENT_MODE_SYMBOL_STRING = "Symbol(react.concurrent_mode)";
var DEPRECATED_ASYNC_MODE_SYMBOL_STRING = "Symbol(react.async_mode)";
var PerformedWork = 1;
var Placement = 2;
var DidCapture = 128;
var Hydrating = 4096;
var Update = 4;
var Cloned = 8;
var ChildDeletion = 16;
var ContentReset = 32;
var Ref = 512;
var Snapshot = 1024;
var Visibility = 8192;
var MutationMask = Placement | Update | ChildDeletion | ContentReset | Hydrating | Visibility | Snapshot;
var isValidElement = (element) => typeof element === "object" && element != null && "$$typeof" in element && // react 18 uses Symbol.for('react.element'), react 19 uses Symbol.for('react.transitional.element')
["Symbol(react.element)", "Symbol(react.transitional.element)"].includes(
  String(element.$$typeof)
);
var isHostFiber = (fiber) => fiber.tag === HostComponentTag || // @ts-expect-error: it exists
fiber.tag === HostHoistableTag || // @ts-expect-error: it exists
fiber.tag === HostSingletonTag;
var isCompositeFiber = (fiber) => fiber.tag === FunctionComponentTag || fiber.tag === ClassComponentTag || fiber.tag === SimpleMemoComponentTag || fiber.tag === MemoComponentTag || fiber.tag === ForwardRefTag;
var traverseContexts = (fiber, selector) => {
  try {
    const nextDependencies = fiber.dependencies;
    const prevDependencies = fiber.alternate?.dependencies;
    if (!nextDependencies || !prevDependencies) return false;
    if (typeof nextDependencies !== "object" || !("firstContext" in nextDependencies) || typeof prevDependencies !== "object" || !("firstContext" in prevDependencies)) {
      return false;
    }
    let nextContext = nextDependencies.firstContext;
    let prevContext = prevDependencies.firstContext;
    while (nextContext && typeof nextContext === "object" && "memoizedValue" in nextContext && prevContext && typeof prevContext === "object" && "memoizedValue" in prevContext) {
      if (selector(nextContext, prevContext) === true)
        return true;
      nextContext = nextContext.next;
      prevContext = prevContext.next;
    }
  } catch {
  }
  return false;
};
var traverseState = (fiber, selector) => {
  try {
    let prevState = fiber.memoizedState;
    let nextState = fiber.alternate?.memoizedState;
    while (prevState && nextState) {
      if (selector(prevState, nextState) === true) return true;
      prevState = prevState.next;
      nextState = nextState.next;
    }
  } catch {
  }
  return false;
};
var traverseProps = (fiber, selector) => {
  try {
    const nextProps = fiber.memoizedProps;
    const prevProps = fiber.alternate?.memoizedProps || {};
    const allKeys = /* @__PURE__ */ new Set([
      ...Object.keys(prevProps),
      ...Object.keys(nextProps)
    ]);
    for (const propName of allKeys) {
      const prevValue = prevProps?.[propName];
      const nextValue = nextProps?.[propName];
      if (selector(propName, nextValue, prevValue) === true) return true;
    }
  } catch {
  }
  return false;
};
var didFiberRender = (fiber) => {
  const nextProps = fiber.memoizedProps;
  const prevProps = fiber.alternate?.memoizedProps || {};
  const flags = fiber.flags ?? fiber.effectTag ?? 0;
  switch (fiber.tag) {
    case ClassComponentTag:
    case FunctionComponentTag:
    case ContextConsumerTag:
    case ForwardRefTag:
    case MemoComponentTag:
    case SimpleMemoComponentTag: {
      return (flags & PerformedWork) === PerformedWork;
    }
    default:
      if (!fiber.alternate) return true;
      return prevProps !== nextProps || fiber.alternate.memoizedState !== fiber.memoizedState || fiber.alternate.ref !== fiber.ref;
  }
};
var didFiberCommit = (fiber) => {
  return Boolean(
    (fiber.flags & (Update | Placement | ChildDeletion)) !== 0 || (fiber.subtreeFlags & (Update | Placement | ChildDeletion)) !== 0
  );
};
var getMutatedHostFibers = (fiber) => {
  const mutations = [];
  const stack = [fiber];
  while (stack.length) {
    const node = stack.pop();
    if (!node) continue;
    if (isHostFiber(node) && didFiberCommit(node) && didFiberRender(node)) {
      mutations.push(node);
    }
    if (node.child) stack.push(node.child);
    if (node.sibling) stack.push(node.sibling);
  }
  return mutations;
};
var getFiberStack = (fiber) => {
  const stack = [];
  while (fiber.return) {
    stack.push(fiber);
    fiber = fiber.return;
  }
  const newStack = new Array(stack.length);
  for (let i = 0; i < stack.length; i++) {
    newStack[i] = stack[stack.length - i - 1];
  }
  return newStack;
};
var shouldFilterFiber = (fiber) => {
  switch (fiber.tag) {
    case DehydratedSuspenseComponent:
      return true;
    case HostText:
    case Fragment:
    case LegacyHiddenComponent:
    case OffscreenComponent:
      return true;
    case HostRoot:
      return false;
    default: {
      const symbolOrNumber = typeof fiber.type === "object" && fiber.type !== null ? fiber.type.$$typeof : fiber.type;
      const typeSymbol = typeof symbolOrNumber === "symbol" ? symbolOrNumber.toString() : symbolOrNumber;
      switch (typeSymbol) {
        case CONCURRENT_MODE_NUMBER:
        case CONCURRENT_MODE_SYMBOL_STRING:
        case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
          return true;
        default:
          return false;
      }
    }
  }
};
var getNearestHostFiber = (fiber) => {
  let hostFiber = traverseFiber(fiber, isHostFiber);
  if (!hostFiber) {
    hostFiber = traverseFiber(fiber, isHostFiber, true);
  }
  return hostFiber;
};
var traverseFiber = (fiber, selector, ascending = false) => {
  if (!fiber) return null;
  if (selector(fiber) === true) return fiber;
  let child = ascending ? fiber.return : fiber.child;
  while (child) {
    const match = traverseFiber(child, selector, ascending);
    if (match) return match;
    child = ascending ? null : child.sibling;
  }
  return null;
};
var getTimings = (fiber) => {
  const totalTime = fiber?.actualDuration ?? 0;
  let selfTime = totalTime;
  let child = fiber?.child ?? null;
  while (totalTime > 0 && child != null) {
    selfTime -= child.actualDuration ?? 0;
    child = child.sibling;
  }
  return { selfTime, totalTime };
};
var hasMemoCache = (fiber) => {
  return Boolean(fiber.updateQueue?.memoCache);
};
var getType = (type) => {
  if (typeof type === "function") {
    return type;
  }
  if (typeof type === "object" && type) {
    return getType(type.type || type.render);
  }
  return null;
};
var getDisplayName = (type) => {
  if (typeof type !== "function" && !(typeof type === "object" && type)) {
    return null;
  }
  const name = type.displayName || type.name || null;
  if (name) return name;
  type = getType(type);
  if (!type) return null;
  return type.displayName || type.name || null;
};
var isUsingRDT = () => globalThis.__REACT_DEVTOOLS_BACKEND_MANAGER_INJECTED__ != null;
var detectReactBuildType = (renderer) => {
  try {
    if (typeof renderer.version === "string" && renderer.bundleType > 0) {
      return "development";
    }
  } catch {
  }
  return "production";
};
var checkDCE = (fn) => {
  try {
    const code = Function.prototype.toString.call(fn);
    if (code.indexOf("^_^") > -1) {
      setTimeout(() => {
        throw new Error(
          "React is running in production mode, but dead code elimination has not been applied. Read how to correctly configure React for production: https://reactjs.org/link/perf-use-production-build"
        );
      });
    }
  } catch {
  }
};
var NO_OP = () => {
};
var installRDTHook = (onActive) => {
  const renderers = /* @__PURE__ */ new Map();
  let i = 0;
  const rdtHook = {
    checkDCE,
    supportsFiber: true,
    supportsFlight: true,
    renderers,
    onCommitFiberRoot: NO_OP,
    onCommitFiberUnmount: NO_OP,
    onPostCommitFiberRoot: NO_OP,
    inject(renderer) {
      const nextID = ++i;
      renderers.set(nextID, renderer);
      if (!rdtHook._instrumentationIsActive) {
        rdtHook._instrumentationIsActive = true;
        onActive?.();
      }
      return nextID;
    },
    _instrumentationSource: BIPPY_INSTRUMENTATION_STRING,
    _instrumentationIsActive: false
  };
  try {
    Object.defineProperty(globalThis, "__REACT_DEVTOOLS_GLOBAL_HOOK__", {
      configurable: true,
      value: rdtHook
    });
  } catch {
  }
  return rdtHook;
};
var getRDTHook = (onActive) => {
  let rdtHook = globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (rdtHook) onActive?.();
  if (!window.hasOwnProperty("__REACT_DEVTOOLS_GLOBAL_HOOK__")) {
    rdtHook = installRDTHook(onActive);
  }
  return rdtHook;
};
var isInstrumentationActive = () => {
  const rdtHook = getRDTHook();
  return Boolean(rdtHook._instrumentationIsActive) || isUsingRDT();
};
var mountFiberRecursively = (onRender, firstChild, traverseSiblings) => {
  let fiber = firstChild;
  while (fiber != null) {
    const shouldIncludeInTree = !shouldFilterFiber(fiber);
    if (shouldIncludeInTree && didFiberRender(fiber)) {
      onRender(fiber, "mount");
    }
    if (fiber.tag === SuspenseComponentTag) {
      const isTimedOut = fiber.memoizedState !== null;
      if (isTimedOut) {
        const primaryChildFragment = fiber.child;
        const fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;
        if (fallbackChildFragment) {
          const fallbackChild = fallbackChildFragment.child;
          if (fallbackChild !== null) {
            mountFiberRecursively(onRender, fallbackChild, false);
          }
        }
      } else {
        let primaryChild = null;
        if (fiber.child !== null) {
          primaryChild = fiber.child.child;
        }
        if (primaryChild !== null) {
          mountFiberRecursively(onRender, primaryChild, false);
        }
      }
    } else if (fiber.child != null) {
      mountFiberRecursively(onRender, fiber.child, true);
    }
    fiber = traverseSiblings ? fiber.sibling : null;
  }
};
var updateFiberRecursively = (onRender, nextFiber, prevFiber, parentFiber) => {
  if (!prevFiber) return;
  const isSuspense = nextFiber.tag === SuspenseComponentTag;
  const shouldIncludeInTree = !shouldFilterFiber(nextFiber);
  if (shouldIncludeInTree && didFiberRender(nextFiber)) {
    onRender(nextFiber, "update");
  }
  const prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;
  const nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null;
  if (prevDidTimeout && nextDidTimeOut) {
    const nextFallbackChildSet = nextFiber.child?.sibling ?? null;
    const prevFallbackChildSet = prevFiber.child?.sibling ?? null;
    if (nextFallbackChildSet !== null && prevFallbackChildSet !== null) {
      updateFiberRecursively(
        onRender,
        nextFallbackChildSet,
        prevFallbackChildSet);
    }
  } else if (prevDidTimeout && !nextDidTimeOut) {
    const nextPrimaryChildSet = nextFiber.child;
    if (nextPrimaryChildSet !== null) {
      mountFiberRecursively(onRender, nextPrimaryChildSet, true);
    }
  } else if (!prevDidTimeout && nextDidTimeOut) {
    unmountFiberChildrenRecursively(onRender, prevFiber);
    const nextFallbackChildSet = nextFiber.child?.sibling ?? null;
    if (nextFallbackChildSet !== null) {
      mountFiberRecursively(onRender, nextFallbackChildSet, true);
    }
  } else if (nextFiber.child !== prevFiber.child) {
    let nextChild = nextFiber.child;
    while (nextChild) {
      if (nextChild.alternate) {
        const prevChild = nextChild.alternate;
        updateFiberRecursively(
          onRender,
          nextChild,
          prevChild);
      } else {
        mountFiberRecursively(onRender, nextChild, false);
      }
      nextChild = nextChild.sibling;
    }
  }
};
var unmountFiber = (onRender, fiber) => {
  const isRoot = fiber.tag === HostRoot;
  if (isRoot || !shouldFilterFiber(fiber)) {
    onRender(fiber, "unmount");
  }
};
var unmountFiberChildrenRecursively = (onRender, fiber) => {
  const isTimedOutSuspense = fiber.tag === SuspenseComponentTag && fiber.memoizedState !== null;
  let child = fiber.child;
  if (isTimedOutSuspense) {
    const primaryChildFragment = fiber.child;
    const fallbackChildFragment = primaryChildFragment?.sibling ?? null;
    child = fallbackChildFragment?.child ?? null;
  }
  while (child !== null) {
    if (child.return !== null) {
      unmountFiber(onRender, child);
      unmountFiberChildrenRecursively(onRender, child);
    }
    child = child.sibling;
  }
};
var commitId = 0;
var rootInstanceMap = /* @__PURE__ */ new WeakMap();
var createFiberVisitor = ({
  onRender: onRenderWithoutState,
  onError
}) => {
  return (_rendererID, root, state) => {
    const rootFiber = root.current;
    const onRender = (fiber, phase) => onRenderWithoutState(fiber, phase, state);
    let rootInstance = rootInstanceMap.get(root);
    if (!rootInstance) {
      rootInstance = { prevFiber: null, id: commitId++ };
      rootInstanceMap.set(root, rootInstance);
    }
    const { prevFiber } = rootInstance;
    try {
      if (!rootFiber) {
        unmountFiber(onRender, root);
      } else if (prevFiber !== null) {
        const wasMounted = prevFiber && prevFiber.memoizedState != null && prevFiber.memoizedState.element != null && // A dehydrated root is not considered mounted
        prevFiber.memoizedState.isDehydrated !== true;
        const isMounted = rootFiber.memoizedState != null && rootFiber.memoizedState.element != null && // A dehydrated root is not considered mounted
        rootFiber.memoizedState.isDehydrated !== true;
        if (!wasMounted && isMounted) {
          mountFiberRecursively(onRender, rootFiber, false);
        } else if (wasMounted && isMounted) {
          updateFiberRecursively(
            onRender,
            rootFiber,
            rootFiber.alternate,
            null
          );
        } else if (wasMounted && !isMounted) {
          unmountFiber(onRender, rootFiber);
        }
      } else {
        mountFiberRecursively(onRender, rootFiber, false);
      }
    } catch (err) {
      if (onError) {
        onError(err);
      } else {
        throw err;
      }
    }
    rootInstance.prevFiber = rootFiber;
  };
};
var instrument = ({
  onCommitFiberRoot,
  onCommitFiberUnmount,
  onPostCommitFiberRoot,
  onActive,
  name
}) => {
  const devtoolsHook = getRDTHook(onActive);
  devtoolsHook._instrumentationSource = name ?? BIPPY_INSTRUMENTATION_STRING;
  const prevOnCommitFiberRoot = devtoolsHook.onCommitFiberRoot;
  if (onCommitFiberRoot) {
    devtoolsHook.onCommitFiberRoot = (rendererID, root, priority) => {
      if (prevOnCommitFiberRoot)
        prevOnCommitFiberRoot(rendererID, root, priority);
      onCommitFiberRoot(rendererID, root, priority);
    };
  }
  const prevOnCommitFiberUnmount = devtoolsHook.onCommitFiberUnmount;
  if (onCommitFiberUnmount) {
    devtoolsHook.onCommitFiberUnmount = (rendererID, root) => {
      if (prevOnCommitFiberUnmount) prevOnCommitFiberUnmount(rendererID, root);
      onCommitFiberUnmount(rendererID, root);
    };
  }
  const prevOnPostCommitFiberRoot = devtoolsHook.onPostCommitFiberRoot;
  if (onPostCommitFiberRoot) {
    devtoolsHook.onPostCommitFiberRoot = (rendererID, root) => {
      if (prevOnPostCommitFiberRoot) {
        prevOnPostCommitFiberRoot(rendererID, root);
      }
    };
  }
  return devtoolsHook;
};
var isBrowser = typeof document !== "undefined" && typeof document.createElement === "function";
var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
if (isBrowser || !isNode) {
  installRDTHook();
}

exports.BIPPY_INSTRUMENTATION_STRING = BIPPY_INSTRUMENTATION_STRING;
exports.CONCURRENT_MODE_NUMBER = CONCURRENT_MODE_NUMBER;
exports.CONCURRENT_MODE_SYMBOL_STRING = CONCURRENT_MODE_SYMBOL_STRING;
exports.ChildDeletion = ChildDeletion;
exports.ClassComponentTag = ClassComponentTag;
exports.Cloned = Cloned;
exports.ContentReset = ContentReset;
exports.ContextConsumerTag = ContextConsumerTag;
exports.DEPRECATED_ASYNC_MODE_SYMBOL_STRING = DEPRECATED_ASYNC_MODE_SYMBOL_STRING;
exports.DehydratedSuspenseComponent = DehydratedSuspenseComponent;
exports.DidCapture = DidCapture;
exports.ForwardRefTag = ForwardRefTag;
exports.Fragment = Fragment;
exports.FunctionComponentTag = FunctionComponentTag;
exports.HostComponentTag = HostComponentTag;
exports.HostHoistableTag = HostHoistableTag;
exports.HostRoot = HostRoot;
exports.HostSingletonTag = HostSingletonTag;
exports.HostText = HostText;
exports.Hydrating = Hydrating;
exports.LegacyHiddenComponent = LegacyHiddenComponent;
exports.MemoComponentTag = MemoComponentTag;
exports.MutationMask = MutationMask;
exports.OffscreenComponent = OffscreenComponent;
exports.OffscreenComponentTag = OffscreenComponentTag;
exports.PerformedWork = PerformedWork;
exports.Placement = Placement;
exports.Ref = Ref;
exports.SimpleMemoComponentTag = SimpleMemoComponentTag;
exports.Snapshot = Snapshot;
exports.SuspenseComponentTag = SuspenseComponentTag;
exports.Update = Update;
exports.Visibility = Visibility;
exports.createFiberVisitor = createFiberVisitor;
exports.detectReactBuildType = detectReactBuildType;
exports.didFiberCommit = didFiberCommit;
exports.didFiberRender = didFiberRender;
exports.getDisplayName = getDisplayName;
exports.getFiberStack = getFiberStack;
exports.getMutatedHostFibers = getMutatedHostFibers;
exports.getNearestHostFiber = getNearestHostFiber;
exports.getRDTHook = getRDTHook;
exports.getTimings = getTimings;
exports.getType = getType;
exports.hasMemoCache = hasMemoCache;
exports.installRDTHook = installRDTHook;
exports.instrument = instrument;
exports.isCompositeFiber = isCompositeFiber;
exports.isHostFiber = isHostFiber;
exports.isInstrumentationActive = isInstrumentationActive;
exports.isUsingRDT = isUsingRDT;
exports.isValidElement = isValidElement;
exports.mountFiberRecursively = mountFiberRecursively;
exports.shouldFilterFiber = shouldFilterFiber;
exports.traverseContexts = traverseContexts;
exports.traverseFiber = traverseFiber;
exports.traverseProps = traverseProps;
exports.traverseState = traverseState;
exports.unmountFiber = unmountFiber;
exports.unmountFiberChildrenRecursively = unmountFiberChildrenRecursively;
exports.updateFiberRecursively = updateFiberRecursively;
exports.version = version;
